use std::path::Path;
use std::env;
use reqwest::Client;
use serde::{Serialize, Deserialize};
use serde_json::Value;
use tokio::fs::{File, create_dir_all};
use tokio::io::AsyncWriteExt;

#[tokio::main]
async fn main() -> Result<(), reqwest::Error> {
	let region_id = env::var("REGION_ID").unwrap_or("cn-north-4".to_string());
	let client = Client::new();
	let list_products_resp = list_products(&client).await?;
	let out_dir = env::var("OUT_DIR").unwrap();
	let gen_dir = Path::new(&out_dir);
	create_dir_all(&gen_dir).await.expect("create dir");
	
	let mut product_names = Vec::new();
  for group in list_products_resp.groups {
			for product in group.products.iter() {
				let productshort = &product.productshort;
					let list_apis_resp = list_apis(&client, productshort).await;
					let list_apis_resp = match list_apis_resp {
						Ok(list_apis_resp) => list_apis_resp,
						Err(e) => {
							println!("Skip {} because of error {}", productshort, e);
							continue;
						}
					};

					if list_apis_resp.count == 0 {
						println!("Skip {} because of no apis", productshort);
						continue;
					}

					product_names.push(productshort.clone());

					let tasks = list_apis_resp.api_basic_infos
						.iter()
						.map(|api_basic_info| {
							let gen_dir = gen_dir.clone();
							let productshort = productshort.clone();
							let client = client.clone();
							let region_id = region_id.clone();
							async move {
								let api_detail_resp = get_api_detail(&client, &productshort, &api_basic_info.name, &region_id).await;
								match api_detail_resp {
									Ok(api_detail) => {
										let path = format!("{}/{}/{}.json", gen_dir.display(), productshort, api_basic_info.name);
										let url = api_detail_url(&productshort, &api_basic_info.name, &region_id);
										typify_gen_definition(path, &api_basic_info.name, &url, api_detail.to_string().as_bytes()).await;
										Some(api_basic_info.name.clone())
									},
									Err(e) => {
										println!("Skip {}-{} because of error {}", productshort, api_basic_info.name, e);
										None
									}
								}
							}
						});
					let api_names = futures::future::join_all(tasks).await.into_iter().filter_map(|x| x).collect::<Vec<String>>();
					write_file(format!("{}/{}/mod.rs", gen_dir.display(), productshort), mod_gen(&api_names).as_bytes()).await;
					break;
			}
	}

	write_file(format!("{}/mod.rs", &gen_dir.display()), feature_mod_gen(&product_names).as_bytes()).await;

	println!("cargo:rustc-env=GENERATED_ENV={}", gen_dir.display());

	Ok(())
}

async fn write_file<P: AsRef<Path>>(path: P, content: &[u8]) {
	let parent = path.as_ref().parent().expect("parent");
	create_dir_all(parent).await.expect("create dir");
	let mut file = match tokio::fs::OpenOptions::new().write(true).truncate(true).open(path.as_ref()).await {
		Err(e) => {
			println!("file may not exist, try to create it: {}", e);
			tokio::fs::File::create(path.as_ref()).await.expect("create file")
		},
		Ok(file) => file,
	};
	file
		.write_all(content)
		.await.expect("write file");
}

async fn typify_gen_definition<P: AsRef<Path>>(path: P, name: &str, reference: &str, content: &[u8]) {
	let schema_file = path.as_ref();
	write_file(schema_file, content).await;

	let companie_rs = path
		.as_ref()
		.parent()
		.expect("parent")
		.join(format!("{}.rs", name));
	write_file(companie_rs, companie_rs_gen(path.as_ref(), reference).as_bytes()).await;
}

fn companie_rs_gen<P: AsRef<Path>>(schema: P, reference: &str) -> String {
	format!(r#"
		// This file is generated by hw-cloud-schema/build.rs
		// Definition: {}
		use std::fmt::Debug;
		use serde::{{Serialize, Deserialize}};
		use typify::import_types;
		import_types!("{}");
	"#, reference, schema.as_ref().display())
}

fn feature_mod_gen(name_list: &[String]) -> String {
	let mut mod_gen = String::new();
	for name in name_list {
		// feature = name
		mod_gen.push_str(&format!("#[cfg(feature = \"{}\")]\n", name));
		mod_gen.push_str(&format!("pub mod {};\n", name));
		println!("cargo:rustc-cfg={}", name);
	}
	mod_gen
}

fn mod_gen(name_list: &[String]) -> String {
	let mut mod_gen = String::new();
	for name in name_list {
		mod_gen.push_str(&format!("pub mod {};\n", name));
	}
	mod_gen
}

#[derive(Debug, Serialize, Deserialize)]
struct ListProductsResponse {
	groups: Vec<Group>,
}

#[derive(Debug, Serialize, Deserialize)]
struct Group {
	id: String,
	name: String,
	products: Vec<Product>,
}

#[derive(Debug, Serialize, Deserialize)]
struct Product {
	api_count: u32,
	attributive_product: String,
	description: String,
	has_data: bool,
	icon: String,
	is_global: bool,
	is_recommend: bool,
	link: String,
	name: String,
	productshort: String,
}

// https://console.huaweicloud.com/apiexplorer/new/v5/products
async fn list_products(client: &Client) -> Result<ListProductsResponse, reqwest::Error> {
	let products = client.get("https://console.huaweicloud.com/apiexplorer/new/v5/products")
		.send()
		.await?
		.json::<ListProductsResponse>()
		.await?;

	Ok(products)
}

#[derive(Debug, Serialize, Deserialize)]
struct ListApisResponse {
	count: u32,
	api_basic_infos: Vec<ApiBasicInfo>,
}

#[derive(Debug, Serialize, Deserialize)]
struct ApiBasicInfo {
	alias_name: String,
	id: String,
	info_version: String,
	method: String,
	name: String,
	product_short: String,
	summary: String,
	tags: String,
}

// https://console.huaweicloud.com/apiexplorer/new/v3/apis?offset=0&limit=100&product_short=MetaStudio
async fn list_apis(client: &Client, product_short: &str) -> Result<ListApisResponse, reqwest::Error> {
	let url = format!("https://console.huaweicloud.com/apiexplorer/new/v3/apis?offset=0&limit=100&product_short={}", product_short);
	let apis = client.get(url)
		.send()
		.await?
		.json::<ListApisResponse>()
		.await?;

	Ok(apis)
}

// https://console.huaweicloud.com/apiexplorer/new/v4/apis/detail?product_short=MetaStudio&name=CreateSmartLiveRoom&region_id=cn-north-4
async fn get_api_detail(client: &Client, product_short: &str, api_name: &str, region_id: &str) -> Result<Value, reqwest::Error> {
	let url = api_detail_url(product_short, api_name, region_id);
	let api_detail = client.get(url)
		.send()
		.await?
		.json::<Value>()
		.await?;

	Ok(api_detail)
}

fn api_detail_url(product_short: &str, api_name: &str, region_id: &str) -> String {
	format!("https://console.huaweicloud.com/apiexplorer/new/v4/apis/detail?product_short={}&name={}&region_id={}", product_short, api_name, region_id)
}